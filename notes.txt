

Routes in laravel

    simple Routing
        The / will automatically identify the files inside resources/views Folder.

        Ex:-
            Route::any('/program_1/post', function () {
                return view('welcome');
            });
    
        OR create direct view route 
                Route::view('/path', 'viewFileName');


    Dynamic Routing

        Ex :- 
            Route::get('student/{id}', function ($id) { 
                echo "Student " . $id;
            });

    FallBack Route(Invalid Route)
        calles when the route is not found.

        Ex:- 
            Route::fallback(function () {
                return "please enter valid url";
            });
            
            
Pass data from route to view 

    send data :-

        using compact, 
            Route::get('/', function () {
                $data = "Data from web.php file";               
                return view('test', compact('data'));               // compact only allows variables
            });

        OR 

        using with function,
            Route::get('/', function () {
                $data = "Data from web.php file";               
                return view('test')->with('data',$data);               
            });

        OR 

        using key value array data,
            Route::get('/', function () {   
                return view('test',['key'=>value,'key'=>value]);               
            });


    Recive Data :-

        in target .php file 
            {{ $variable_name }}                                          // to access variable 
            {{ request()->parameter_Name }}                               // to access url variable 


Create view file terminal
    Command :- php artisan make:view contactUs                      // It will automatically creates contactUs.blade.php file under views Folder



Looping in blade file
    the loop starts with @for and ends with @endfor

    Ex:-
        @for($i=0;$i<10;$i++)
            <p> {{$i}} </p>                     // It doesn't require {} brackets in loop
        @endfor

Blade Templates:-

    Condition in blade file
        the Condition statements start with @if and ends with @endif

        Ex:-
            @if($i<0)
                <p> {{$i}} is Less then 0</p>
            @else
                <p> {{$i}} is Greater then 0</p>
            @endif

    For More Templates https://laravel.com/docs/12.x/blade

Adding sub components/views

    @include('fileName')

    Ex:-
        @include('subViews.input')
        
    call subview with data passing
            @include('subViews.input',[
                'lableFor' => 'Name',
                'myName' => 'Umang'
            ])                              // assess those data from subview with {{ $variable_name}}



Terminal commands
    To get the all routes in terminal
        Command :- php artisan route:list

            it will return all the routes list with 2 other routes
            up : - to see our application is up,running or not.
            storage{path} :- later discuss.

    To store site in cache
        Command :- php artisan view:cache

            it will catch the site in catch memory for faster loading.

    To remove cache
        Command :- php artisan view:clear

Master Layout with @extends and @yield

    @extends:
        This directive tells Laravel to extend a layout.

        Example:

        @extends('layouts.app')


    @yield:
        Used in the layout to define a placeholder for content.

        Example:

        <title>@yield('title', 'My Laravel App')</title>


    @section:
        Defines content for a specific section that will be injected into the layout's @yield.

        Example:

        @section('title', 'Home Page')

        or

        @section('content')
            <p>Welcome to the home page!</p>
        @endsection


        or

        @section('title')
            @include('Components.title', ['title' => 'Home Page'])
        @endsection

        
    @show:
        Immediately displays the content of a section after it's been defined.

        Example:

        @section('header')
            <h2>Header Content</h2>
        @show


Controllers
    controllers are the main part of MVC.
    It can get data from view, process data and set back data to view.
    It has ability to get data from database/Model also.

    Create a controller 
        Mannylally inside App/Http/Controllers

        OR 
        
        using command : php artisan make:controller controller_name

    Ex :-
        class StudentController extends Controller
        {
            public function  index()
            {
                return "From Student Controller";
            }
        }

    route FOR controller
        Route::get('controller', [StudentController::class, 'index']);

    controller Route Group
        Route::controller(StudentController::class)->group(function () {
            Route::get('studentController', 'index');
            Route::get('aboutstudent', 'aboutStudent');
        });

    pass data to the controller
        Route::controller(StudentController::class)->group(function () {
            Route::get('studentController', 'index');
            Route::get('aboutstudent/{id}/{name}', 'aboutStudent');
        });


    Private Controllers
        Private controller can only access within the same class.

        private function  studentResult($id)
        {
            return "Student Id " . $id . " has 50 marks";
        }


    __construct() :-
        it automatically calles when object is created.
        whenever we need any calculation ,run any logic, or anything computation.

        Ex:-
            protected $status;                              // Global variable
            public function __construct()
            {
                $this->status = "fail";
            }

    Types of controllers
        1) Invokable controller 
        2) Resource controller

        1) Invokable controller
            it is also called single maod controller which means if any controller have only 1 function and we don't want to use like index,create,update,delete etc.
            it has only 1 method where we can put our logic which is __invoke function

            create command :-   php artisan make:controller controller_name --invokable

            Example file :-
                class invokableController extends Controller
                {
                    public function __invoke(Request $request)
                    {
                        return "Inside invokable controller";
                    }
                }
            
            route for invokableController
                Route::get('/invoke', InvokableController::class); // don't need to specify method automatically gets __invoke

        2) Resource Controller :-
            it has already predefined methods index, create, store, show, edit, update and destroy.

            create command :- php artisan make:controller controller_name --resource

            Route::resource('/resource', ResourceController::class);        // To call resource controller

    Migration in Laravel
        Migrations are version control for out database similar like gate which is version control for our code 

        we track our changes over time and that database table it allows us to define table structures and update them over time using php code instade of writing row SQL query and creating tables or changing them Mannylally.

        the migrations are showm inside database/migrations Folder
        command :- 
            php artisan migrate // for check all required tables are awailable or not
            php artisan make:migration StudentTable         // creates migration file

        The migration file has by default 2 methods up() and down()

        up() - it is used for creating table structures
        down() - to reverse migration

        to create migration table with command
             php artisan make:migration create_tablename_table
        
        it has by default this methods 
            public function up(): void
            {
                Schema::create('students', function (Blueprint $table) {
                    $table->id();                       // columns
                    $table->timestamps();
                });
            }

            /**
            * Reverse the migrations.
            */
            public function down(): void
            {
                Schema::dropIfExists('students');
            }

        Example create student table 
            Schema::create('students', function (Blueprint $table) {
                $table->id();
                $table->string('studentName');
                $table->integer('age');
                $table->float('percentage');
                $table->timestamps();
            });

            it automatically adds 2 columns created_at and updated_at

    Modify migration
        php artisan make:migration updateMigrationName --table=table_name
        
        Ex:-php artisan make:migration addUserIDToStudents --table=students


        public function up(): void
        {
            Schema::table('students', function (Blueprint $table) {
                // insert new columns
                $table->date('date_of_birth')->nullable();
                $table->enum('gender', ['male', 'female'])->default('male');
            });
        }

        /**
        * Reverse the migrations.
        */
        public function down(): void
        {
            Schema::table('students', function (Blueprint $table) {
                // columns to be delete
            });
        }
       To rollback last migration :- php artisan migrate:rollback
        To rollback till n migration :- php artisan migrate:rollback --step=2

        php artisan migrate:reset // it will reset the database deletes every tables and it's data 
        php artisan migrate:fresh // it will delete all our migrates and remigrates again 


Working with Models
    create Model :- php artisan make:model model_name           //it will create model_name.php file under Http/Models Folder

    CREATE model with controller :- php artisan make:model model_name -mc         // m For migration and c for controller

CRUD operations with model and controller

    //select
    public function index()
    {
        return teacher::all();
    }

    //insert
    public function add()
    {
        $item = new teacher();
        $item->name = 'test';
        $item->save();
        return teacher::all();
    }

    //select 1
    public function getTeacher($id)
    {
        $item = teacher::findOrFail($id);

        return $item;
    }

    //update
    public function updateTeacher($id)
    {
        $item = teacher::findOrFail($id);
        $item->name = 'abcd';
        $item->update();
        return "updated";
    }
    

    //delete
    public function deleteTeacher($id)
    {
        $item = teacher::findOrFail($id);
        $item->delete();
        return "deleted";
    }


Routes for CRUD

Route::get('teachers', [TeacherController::class, 'index']);
Route::get('addTeacher', [TeacherController::class, 'add']);
Route::get('getTeacher/{id}', [TeacherController::class, 'getTeacher']);
Route::get('updateTeacher/{id}', [TeacherController::class, 'updateTeacher']);
Route::get('deleteTeacher/{id}', [TeacherController::class, 'deleteTeacher']);



Factory
    used for testing / temparary data

    command :- php artisan make:factory factoryName --model=model_name

    Ex :- php artisan make:factory StudentFactory --model=student
    

Problem: user_id field error

    Error: Field 'user_id' doesn't have a default value during seeding.

    Cause: user_id column is required but not provided in factory or seeder.

    Fix

        Add user_id to StudentFactory.php like this:

        'user_id' => User::factory(),


    This makes sure each student is linked to a user.

    Optional: Make user_id nullable

        Change migration to:

        $table->foreignId('user_id')->nullable()->constrained('users');


    Run migrations again with:

    php artisan migrate:fresh --seed

    Create Country seeder :-php artisan make:seeder CountriesSeeder

    List of countries :- https://gist.github.com/keeguon/2310008

    Run CountriesSeeder :- php artisan db:seed --class=CountriesSeeder


Run sql queries in laravel
    there are 3 approaches

    1)Raw SQL
        security :- High risk of SQl injection if not properly handled
        Performance :- Fastest because it directly intrects with the database.
        Flexibility :- Fully customizable, allows complex queries.
        Maintainability :- Harder to maintain and debug, requires manual query writing.



    2)Query Builder
        security :- Protects agains SQL injection.
        Performance :- Faster then Eloquent but slower then Raw SQL
        Flexibility :- Flexibile, allows complex queries with readable syntax.
        Maintainability :- Easier to maintain then ROW SQL but lacks full ORM capabilities.

        Ex:- 
        Insert data using Query Builder
            DB::table('students')->insert([
                "studentName" => 'test',
                "age" => 20,
                "date_of_birth" => '2005-03-16',
                "gender" => 'male',
                "percentage" => 99,
                "user_id" => 10
            ]);

        Select data using Query Builder
            public function getData()
            {
                return DB::table('students')->get();                
            }
            // get data with limit DB::table('students')->limit(5)->get();
            // get first row DB::table('students')->first();
            // get last row DB::table('students')->last();
            // get data with where case DB::table('students')->where('column','Condition',value);           Ex-where('salary','>=',=10000)
            // select only required column DB::table('students')->select('name','number');

        update data
            DB::table('students')->where('id', $id)->update([
                'studentName' => "student5"
            ]);

        Delete data 
            DB::table('students')->where('id', $id)->delete();

        Aggrigate functions in Query Builder
            public function getStudentsCount()
            {
                return DB::table('students')->count();
            }

    3)Eloquent ORM [Eloquent  Object-Relational Mapping]
        security :- High secure , Prevents SQL injection
        Performance :- Slowest because of abstraction overhead
        Flexibility :- Less Flexibile for hign optimized queries
        Maintainability :- Easier to maintain follows object-oriented principles

        Insert data using Eloquent ORM
            $item = new Student();
            $item->name = 'test';
            $item->save();

        Select Data 
            //Eloquent ORM
            //Student::all();

        create restriction inside model file
            protected $hidden = [
                'studentName'
            ];                  /// it will not display name column and can be use with Eloquent ORM only
        
    Where Types
        simple where
            Students::where('name','abc');
    
        multiple where
            Students::where('name','abc')->orWhere('id',">=",20);
    
        whereAny
            Students::whereAny(['age','score'],'=',25)->get();          //any from age or score equal to 25
    
        whereAll
            Students::whereAll(['age','score','id'],'=',25)->get();          //all from age and score and id equal to 25

    Query Scope
        when we reyuier same query output multiple times then the query score is usefull

        the function name should start with scope inside model file
        Ex :-
            public function scopeMale($query)
            {
                return $query->where('gender', 'male');
            }

        To access these function 
            $items = Student::male()->get();           // from controller file, we can further add more conditions as needed

    Soft delete
        To create soft delete first we needed to add column deleted at for track deleted records

        command to create soft delete mjgration :-  php artisan make:migration addSoftDeleteToStudentsTable

            It does not delete the data but the deleted record does not seleted

        inside controller
            $item = Student::findOrFail($id);
            $item->delete();

        To get deleted record   
            $item = Student::onlyTrashed()->get();          // to selected deleted students
            $item = Student::withTrashed()->get();          // to selected all students including deleted students

        Restore deleted students
            $item = Student::withTrashed()->find(7)->restore();     // to restore deleted stuedent

        To permanently delete item
            Student::find(id)->forceDelete();


Implement Search Optional
    add request parameter to function to handle the incomming request

    Route::get('/', function () {
        $students = (new StudentController)->index(request());;
        return view('home', compact('students'));
    });


    Controller
        WITHOUT LIMITATION/PAGINATION/like query
            public function index(Request $request)
            {
                // return Student::all();
                return Student::when($request->search, function ($query) use ($request) {
                    return $query->whereAny([
                        'studentName',
                        'age',
                        'percentage',
                        'gender',
                        'date_of_birth'
                    ],$request->search);               //SEARCH  QUERY
                })->get();                                           // WITHOUT LIMITATION/PAGINATION
            }
        
        WITHOUT LIMITATION/PAGINATION with like query
            public function index(Request $request)
            {
                // return Student::all();
                return Student::when($request->search, function ($query) use ($request) {
                    return $query->whereAny([
                        'studentName',
                        'age',
                        'percentage',
                        'gender',
                        'date_of_birth'
                    ], 'like', '%' . $request->search . '%');               //SEARCH LIKE QUERY
                })->get();                                           // WITHOUT LIMITATION/PAGINATION
            }
        
        WITH LIMITATION/PAGINATION/like query
            public function index(Request $request)
            {
                // return Student::all();
                return Student::when($request->search, function ($query) use ($request) {
                    return $query->whereAny([
                        'studentName',
                        'age',
                        'percentage',
                        'gender',
                        'date_of_birth'
                    ], 'like', '%' . $request->search . '%');               //SEARCH LIKE QUERY
                })->paginate(10);                                           // WITH LIMITATION/PAGINATION
            }

    Get the requested value from url
        <input type="search" placeholder="Enter student name" id="search" name="search" value="{{ request('search') }}" />

    Handle PAGINATION with bootstrap pagination
        we also need to add cdn link to main app.blade.php file
        <div class="pagination">
            {{ $students->links('pagination::bootstrap-5') }}
        </div>

    Append all previous requests
        appends(request()->query()) for previous requests
        <div class="pagination">
            {{ $students->appends(request()->query())->links('pagination::bootstrap-5') }}
        </div>

display images

    The images should be inside the public folder
    <img src="{{ asset('images/delete.svg') }}" class="deleteButton m-0" alt="Delete">


Insert data from gui
    Route::post('createStudent', 'createStudent');      // Route to create student

    <form method="POST" action="{{ URL('/createStudent') }}"> // Form action to submit insert data

    but here we need to write @csrf after this form line to prevent againts attacks if we did not write it we get 419
Page Expired error

    <form method="POST" action="{{ URL('/createStudent') }}">
    @csrf

    Use of @csrf
        The @csrf Blade directive in Laravel is used to protect web applications from Cross-Site Request Forgery (CSRF) attacks. CSRF is a type of attack where a malicious website tricks an authenticated user into submitting a form or making a request to another website without their knowledge, potentially leading to unauthorized actions. 


        our actual code
            <form method="POST" action="/submit-data">
                @csrf
                <!-- Other form fields -->
                <button type="submit">Submit</button>
            </form>

        This will render as:    
            <form method="POST" action="/submit-data">
                <input type="hidden" name="_token" value="YOUR_CSRF_TOKEN_HERE">
                <!-- Other form fields -->
                <button type="submit">Submit</button>
            </form>

    Here's how @csrf works and its use: 
        - CSRF Token Generation: Laravel automatically generates a unique CSRF "token" for each active user session. This token is a random, unguessable string that is associated with the user's session.
        - Inclusion in Forms: When you use the @csrf Blade directive within an HTML form in your Laravel application, it generates a hidden input field containing this unique CSRF token.
        - Token Validation: When the form is submitted, Laravel's VerifyCsrfToken middleware automatically checks if the submitted token matches the one stored in the user's session. If the tokens don't match or the token is missing, Laravel will reject the request, typically with a 419 HTTP status code (Page Expired), preventing the CSRF attack.
        
    Edit student   
        same as create student just 1 change $student->update();

    Delete student
        to handle delete with conform dialog

        <form action="{{ URL('/deleteStudent/' . $student->id) }}" method="POST"
            onsubmit="return confirm('Are you sure you want to delete this student?')">
            @csrf
            @method('delete')
            <button type="submit" class="deleteButton m-0" style="background: none; border: none;">
                <img src="{{ asset('images/delete.svg') }}" alt="Delete">
            </button>
        </form>

        Button to handle submit form 
        Form to handle confirm dialog
        we also need to change method to delete for delete record   

    Validation from controller
        verify all fields before inserting/updating
        $request->validate([
            'studentName' => 'required|string|max:255',
            'studentUserId' => 'required|integer|max:255',
            'studentAge' => 'required|integer|min:10|max:50',
            'studentDateOfBirth' => 'required|date',
            'studentGender' => 'required|in:male,female',
            'studentPercentage' => 'required|integer|min:0|max:100'
        ]);

    inside view component
        @if ($errors->any())
            <div class="alert alert-denger">
                <ul>
                    @foreach ($errors->all() as $error)
                        <li>{{ $error }}</li>
                    @endforeach
                </ul>
            </div>
        @endif

    We can also write custom error messages
        $request->validate([
            'studentName' => 'required|string|max:255',
            'studentUserId' => 'required|integer|max:255',
            'studentAge' => 'required|integer|min:10|max:50',
            'studentDateOfBirth' => 'required|date',
            'studentGender' => 'required|in:male,female',
            'studentPercentage' => 'required|integer|min:0|max:100'
        ], [
            'studentName.required' => 'Student name is required',
            'studentAge.max' => 'Age must be under 50',
            'studentDateOfBirth.required' => 'Date of birth is required',
            'studentGender.required' => 'Gender is required',
            'studentPercentage.required' => 'Percentage is required',
            'studentUserId.required' => 'User id is required'
        ]);

    Add form Validation for clean and clear codding
        command :- php artisan make:request StudentAddRequest


    then go to Http/Request folder
        make the return type from false to  true
            public function authorize(): bool
            {
                return false;
            }
        
        Put the all rules under this methods

            public function rules(): array
            {
                return [
                    //
                    'studentName' => 'required|string|max:255',
                    'studentUserId' => 'required|integer|max:255',
                    'studentAge' => 'required|integer|min:10|max:50',
                    'studentDateOfBirth' => 'required|date',
                    'studentGender' => 'required|in:male,female',
                    'studentPercentage' => 'required|integer|min:0|max:100'
                ];
            }

        Then add your custom error handling messages to a new method messages
            public function messages()
            {
                return [
                    'studentName.required' => 'Student name is required',
                    'studentAge.max' => 'Age must be under 50',
                    'studentDateOfBirth.required' => 'Date of birth is required',
                    'studentGender.required' => 'Gender is required',
                    'studentPercentage.required' => 'Percentage is required',
                    'studentUserId.required' => 'User id is required'
                ];
            }


        and change the request argument from (Request $request) to (StudentAddRequest $request)

    To get old values back after error replace value="{{ $Student->studentName }}" with value="old('studentName')"


    File storage in laravel
        add enctype="multipart/form-data" property to form element,

    Check if the image is selected or not
        $imagePath = null;
        if ($request->hasFile('studentImage')) {
            $imagePath = $request->file('studentImage')->store('photoes', 'public');
        }

    Check Validation    
        'studentImage' => 'nullable|image|mimes:png,jpg,jpeg,svg,gif|max:2048'

    Store file path in database at the folder location storage/photoes
        $imagePath = null;
        if ($request->hasFile('studentImage')) {
            $imagePath = $request->file('studentImage')->store('photoes', 'public');
        }
        $Student->profileImage = $imagePath;

    Display image in ui

        TO display image in ui first we need to create link from storage folder to public folder with command :php artisan storage:link

        @if ($student->profileImage)
            <img src="{{ asset('storage/' . $student->profileImage) }}" width="50" />
        @endif

    Delete the image when user is deleted 
        if ($student->profileImage) {
            Storage::disk('public')->delete($student->profileImage);
        }

Eloquent Relation ships
    1) One to one
    2) Has-one-Through
    3) One to many
    4) has-many-Through
    5) many to many
    6) Polymorphic

    Eloquent Relationships in Laravel, which is an ORM (Object-Relational Mapping) tool used in Laravel to interact with a database in a more object-oriented manner. The relationships you mentioned define how different models (tables) are related to each other.

    1) One-to-One Relationship

        A one-to-one relationship means that one record in a model is associated with exactly one record in another model.

        Example:

        Let's assume we have two models: User and Profile. Each User has one Profile.

        Database Tables:

        users table

        profiles table (this contains the user_id to reference the users table)

        How to define:

        In the User model:

        public function profile() {
            return $this->hasOne(Profile::class);
        }


        In the Profile model:

        public function user() {
            return $this->belongsTo(User::class);
        }

        Accessing the relation:
        $user = User::find(1);
        $profile = $user->profile;  // Access the related profile

    2) Has-One-Through Relationship

        A has-one-through relationship is used when a model has a one-to-one relationship with another model, but the linking table is in between.

        Example:

        Let's say we have three models: Country, User, and Profile. A Country has many Users, and each User has one Profile. The country indirectly has one Profile through the User.

        Database Tables:

        countries table

        users table (linked to countries)

        profiles table (linked to users)

        How to define:

        In the Country model:

        public function profile() {
            return $this->hasOneThrough(Profile::class, User::class);
        }

        Accessing the relation:
        $country = Country::find(1);
        $profile = $country->profile;  // Access profile of the country through the user

    3) One-to-Many Relationship

        A one-to-many relationship means one record in the first model can be associated with many records in the second model.

        Example:

        Consider a Post and Comment model. A single Post can have many Comments.

        Database Tables:

        posts table

        comments table (this contains post_id to reference the posts table)

        How to define:

        In the Post model:

        public function comments() {
            return $this->hasMany(Comment::class);
        }


        In the Comment model:

        public function post() {
            return $this->belongsTo(Post::class);
        }

        Accessing the relation:
        $post = Post::find(1);
        $comments = $post->comments;  // Get all comments related to this post

    4) Has-Many-Through Relationship

        A has-many-through relationship is used when you want to access a model's related models via an intermediate model, but there is no direct foreign key in the intermediate table for the relationship.

        Example:

        Let's say we have three models: Country, User, and Post. A Country has many Users, and each User has many Posts. The country indirectly has many Posts through Users.

        Database Tables:

        countries table

        users table (linked to countries)

        posts table (linked to users)

        How to define:

        In the Country model:

        public function posts() {
            return $this->hasManyThrough(Post::class, User::class);
        }

        Accessing the relation:
        $country = Country::find(1);
        $posts = $country->posts;  // Get all posts related to the country through users

    5) Many-to-Many Relationship

        A many-to-many relationship means that multiple records in one model can be associated with multiple records in another model.

        Example:

        Consider Role and User models. A User can have many Roles, and a Role can be assigned to many Users.

        Database Tables:

        users table

        roles table

        role_user pivot table (containing user_id and role_id)

        How to define:

        In the User model:

        public function roles() {
            return $this->belongsToMany(Role::class);
        }


        In the Role model:

        public function users() {
            return $this->belongsToMany(User::class);
        }

        Accessing the relation:
        $user = User::find(1);
        $roles = $user->roles;  // Get all roles assigned to this user


        To attach a role to a user:

        $user->roles()->attach($roleId);


        To detach a role from a user:

        $user->roles()->detach($roleId);

    6) Polymorphic Relationships

        A polymorphic relationship allows a model to belong to more than one other model on a single association.

        Example:

        Consider a Comment model that can belong to both Post and Video models. A Comment can be made on either a Post or a Video, so instead of creating two separate tables for comments (post_comments and video_comments), we use a single comments table with a polymorphic relationship.

        Database Tables:

        posts table

        videos table

        comments table (containing commentable_id and commentable_type to reference both Post and Video)

        How to define:

        In the Post model:

        public function comments() {
            return $this->morphMany(Comment::class, 'commentable');
        }


        In the Video model:

        public function comments() {
            return $this->morphMany(Comment::class, 'commentable');
        }


        In the Comment model:

        public function commentable() {
            return $this->morphTo();
        }

        Accessing the relation:
        $post = Post::find(1);
        $comments = $post->comments;  // Get all comments related to the post

        $video = Video::find(1);
        $comments = $video->comments;  // Get all comments related to the video


        To associate a comment with a Post or Video:

        $comment = new Comment();
        $comment->body = 'Nice post!';
        $post->comments()->save($comment);  // This will automatically set commentable_type to 'Post'

    Summary:

        One-to-One: One record in model A is related to one record in model B.

        Has-One-Through: One model (A) has one related model (C), but the relationship is through an intermediary model (B).

        One-to-Many: One record in model A can have many related records in model B.

        Has-Many-Through: One model (A) can have many related models (C) through an intermediary model (B).

        Many-to-Many: Many records in model A can be associated with many records in model B through a pivot table.

        Polymorphic: A model can belong to more than one model, using a single relationship column (type and ID).

        These relationships allow you to design more complex and flexible data models in your Laravel applications.
            additionalResources/Authentication Packages.png

Laravel 12 Authentication Packages: Bootstrap UI, Jetstream, Fortify, and Breeze.
    Feature / Package	Bootstrap UI	Jetstream	Fortify	Breeze
    Primary Focus	Basic authentication with minimal setup	Comprehensive authentication with additional features	Backend-focused authentication (no UI)	Simple authentication with basic UI
    User Interface (UI)	Yes, includes Bootstrap-based UI	Yes, with Tailwind CSS and a complete UI	No built-in UI (only API responses)	Yes, simple UI with Tailwind CSS
    Frontend Framework	Bootstrap	Tailwind CSS (includes livewire for interactivity)	None (No frontend)	Tailwind CSS
    Authentication Features	Login, Register, Forgot Password	Login, Register, Two-Factor Authentication, Profile Management, API Tokens	Login, Registration, Password Reset, Two-Factor Authentication, Email Verification (via API)	Login, Register, Forgot Password
    Two-Factor Authentication	No	Yes	Yes	No
    API Authentication	No	Yes (via Laravel Sanctum)	Yes (via Laravel Sanctum)	No
    Profile Management	No	Yes (with Livewire)	No	No
    Team Management	No	Yes (Team-based features like creating teams, managing roles)	No	No
    Livewire Integration	No	Yes	No	No
    Customizable Views	Yes, but with Bootstrap components	Yes, Tailwind-based views (customizable)	N/A (no views included)	Yes, simple Tailwind-based views
    Multi-Auth Support	Yes, requires manual configuration	Yes, with support for teams and roles	Yes, but requires manual configuration	Yes, but requires manual configuration
    Social Authentication	No	Yes, via Laravel Socialite	No (API-based, no frontend)	No
    Session / Remember Me	Yes, built-in support for sessions	Yes, built-in support for sessions	Yes	Yes
    Password Reset	Yes	Yes	Yes	Yes
    API / SPA Authentication	No	Yes, built-in support (via Laravel Sanctum)	Yes, supports API/SPA authentication	No
    Installation Complexity	Low, quick and simple setup	Moderate, requires more configuration	High, as it's only backend and requires you to build the UI separately	Low, quick and simple setup
    Intended Use Case	Basic app with minimal authentication needs	Full-featured apps requiring user management and team collaboration	API-based apps where authentication is handled via API (no UI)	Simple apps with standard authentication needs
    Supports Laravel Fortify	No	Yes	Yes	No
    Backend Focus	No	Yes (Livewire + Fortify)	Yes (completely backend)	No
    Use Case Examples	Small apps or basic auth functionality	SaaS apps, complex user management, and teams	API-only apps, mobile apps, or SPAs	Small apps, rapid prototypes, or simple authentication needs

    Summary of Differences:

        Bootstrap UI:

            Simple and easy-to-implement package with minimal authentication features.

            Comes with Bootstrap-based UI components but lacks advanced features like two-factor authentication or team management.

            Ideal for small applications where you just need login/register functionalities quickly.

            to install command :- composer require laravel/ui
            to uninstall command :- composer remove laravel/ui
            to run command :-  composer run dev 

        Jetstream:

            Full-featured authentication system built with Tailwind CSS.

            Supports two-factor authentication, team management, profile management, and API token management.

            Recommended for more complex apps like SaaS platforms or applications that require real-time features (Livewire).

            to install command :- composer require laravel/jetstream 
            to install command :- php artisan jetstream:install
                                then choose the Livewire, pest and  Optional settings
            to run command :-  composer run dev 



        Fortify:

            Backend-focused authentication package with no UI components.

            Works well for API-based applications or SPAs where you want to handle authentication through an API (using Laravel Sanctum).

            Highly customizable but requires you to build your own frontend/UI.
            to install command :- composer require laravel/fortify 

            publish the vendor file : php artisan vendor:publish
             then install remaining Packages with npm install

            to uninstall command :- composer remove laravel/breeze
            to run command :-  composer run dev 

        Breeze:

            Simple and minimalistic authentication solution using Tailwind CSS.

            Provides the basic authentication features such as login, registration, and password reset.

            Ideal for small projects, rapid prototyping, or when you need something simple and straightforward without complex features like teams or two-factor authentication.
    
            to install command :- composer require laravel/breeze --dev
                                php artisan breeze:install
                                then select blade then yes then pest

            migrate : php artisan migrate
             then install remaining Packages with npm install

            to uninstall command :- composer remove laravel/breeze
            to run command :-  composer run dev 

                it will store the access tocken in cookies
